{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Vector } from './vector';\n/**\r\n * Props for a particle.\r\n */\n\nexport var Particle = /*#__PURE__*/function () {\n  function Particle(_ref) {\n    var radius = _ref.radius,\n        position = _ref.position,\n        _ref$velocity = _ref.velocity,\n        velocity = _ref$velocity === void 0 ? new Vector(0, 0) : _ref$velocity,\n        _ref$gravity = _ref.gravity,\n        gravity = _ref$gravity === void 0 ? 0 : _ref$gravity,\n        _ref$mass = _ref.mass,\n        mass = _ref$mass === void 0 ? 1 : _ref$mass,\n        _ref$friction = _ref.friction,\n        friction = _ref$friction === void 0 ? 0.99 : _ref$friction,\n        _ref$update = _ref.update,\n        update = _ref$update === void 0 ? true : _ref$update;\n\n    _classCallCheck(this, Particle);\n\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"velocity\", void 0);\n\n    _defineProperty(this, \"mass\", void 0);\n\n    _defineProperty(this, \"gravity\", void 0);\n\n    _defineProperty(this, \"friction\", void 0);\n\n    _defineProperty(this, \"update\", void 0);\n\n    this.radius = radius;\n    this.position = position;\n    this.velocity = velocity;\n    this.mass = mass;\n    this.gravity = new Vector(0, gravity);\n    this.friction = friction;\n    this.update = update;\n  }\n  /**\r\n   * Add the acceleration vector to a the particles velocity.\r\n   * @param v the acceleration vector.\r\n   */\n\n\n  _createClass(Particle, [{\n    key: \"accelerate\",\n    value: function accelerate(v) {\n      if (this.update) {\n        this.velocity.add(v);\n      }\n    }\n    /**\r\n     * Adds friction to the particle.\r\n     */\n\n  }, {\n    key: \"addFriction\",\n    value: function addFriction() {\n      if (this.update) {\n        this.velocity.multiply(this.friction);\n      }\n    }\n    /**\r\n     * Finds the angle to a given particle from the current particle.\r\n     * @param p The particle to find the angle to.\r\n     */\n\n  }, {\n    key: \"angleTo\",\n    value: function angleTo(p) {\n      return Math.atan2(p.position.y - this.position.y, p.position.x - this.position.x);\n    }\n    /**\r\n     * Finds the distance to a given particle from the current particle.\r\n     * @param p The particle to find the distance to.\r\n     */\n\n  }, {\n    key: \"distanceTo\",\n    value: function distanceTo(p) {\n      var dx = p.position.x - this.position.x;\n      var dy = p.position.y - this.position.y;\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }, {\n    key: \"gravitateTo\",\n    value: function gravitateTo(p) {\n      if (this.update) {\n        var gravity = new Vector(0, 0);\n        var distance = this.distanceTo(p);\n        gravity.setLength(p.mass / (distance * distance));\n        gravity.setAngle(this.angleTo(p));\n        this.velocity.add(gravity);\n      }\n    }\n    /**\r\n     * Updates the particle's position by adding in the particle's velocity.\r\n     * Happens only if the particles update property is set to true.\r\n     */\n\n  }, {\n    key: \"updatePosition\",\n    value: function updatePosition() {\n      if (this.update) {\n        this.velocity.add(this.gravity);\n        this.position.add(this.velocity);\n      }\n    }\n    /**\r\n     * Draws the particle as a circle of given radius at the current position.\r\n     * @param ctx The canvas context on which to draw to.\r\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      ctx.beginPath();\n      ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI, false);\n      ctx.fill();\n    }\n    /**\r\n     * Wraps te position to stay within the given width and height.\r\n     * @param width The width to which particle's width will be wrapped.\r\n     * @param height The height to which particle's height will be wrapped.\r\n     */\n\n  }, {\n    key: \"screenWrap\",\n    value: function screenWrap(width, height) {\n      if (this.update) {\n        var _this$position = this.position,\n            x = _this$position.x,\n            y = _this$position.y; // Left boundary.\n\n        if (x + this.radius < 0) {\n          this.position.x = width + this.radius;\n        } // Right boundary.\n\n\n        if (x - this.radius > width) {\n          this.position.x = 0 - this.radius;\n        } // Top boundary.\n\n\n        if (y + this.radius < 0) {\n          this.position.y = height + this.radius;\n        } // Bottom boundary.\n\n\n        if (y - this.radius > height) {\n          this.position.y = 0 - this.radius;\n        }\n      }\n    }\n    /**\r\n     * This will bounce the particle of the inside the given width and heigth.\r\n     * @param width The width at which particles will be bounced off of.\r\n     * @param height The height at which particles will be bounced off of.\r\n     */\n\n  }, {\n    key: \"bounceOfEdges\",\n    value: function bounceOfEdges(width, height) {\n      if (this.update) {\n        // Left edge.\n        if (this.position.x - this.radius < 0) {\n          this.position.x = this.radius;\n          this.velocity.x *= -1;\n        } // Right edge.\n\n\n        if (this.position.x + this.radius > width) {\n          this.position.x = width - this.radius;\n          this.velocity.x *= -1;\n        } // Top edge.\n\n\n        if (this.position.y - this.radius < 0) {\n          this.position.y = this.radius;\n          this.velocity.y *= -1;\n        } // Bottom edge.\n\n\n        if (this.position.y + this.radius > height) {\n          this.position.y = height - this.radius;\n          this.velocity.y *= -1;\n        }\n      }\n    }\n  }]);\n\n  return Particle;\n}();","map":null,"metadata":{},"sourceType":"module"}