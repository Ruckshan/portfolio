{"ast":null,"code":"import { useEffect } from 'react';\nimport { randomBetween, roundToEven } from '.';\nimport { Particle } from './particle';\nimport { Vector } from './vector';\n/**\r\n * Custom hook used to draw the face vector on about page.\r\n */\n\nexport function useLandingPageCanvasEffect() {\n  useEffect(() => {\n    /**\r\n     * Small fish properties.\r\n     */\n    const SMALL_FISH = {\n      /**\r\n       * It's Size.\r\n       */\n      SIZE: 1,\n\n      /**\r\n       * The total number of small fish.\r\n       */\n      COUNT: 200,\n\n      /**\r\n       * The color of the small fish.\r\n       */\n      COLOR: '#eefac9',\n\n      /**\r\n       * The distance to which the small fish are attracted to food.\r\n       */\n      FOOD_ATTRACTION_RADIUS: 100,\n\n      /**\r\n       * The distance to which the small fish are attracted to mouse pointer.\r\n       */\n      MOUSE_ATTRACTION_RADIUS: 100\n    };\n    /**\r\n     * The food particle color.\r\n     */\n\n    const FOOD_COLOR = '#e6db74';\n    /**\r\n     * The number of food particles droppen when double tapped.\r\n     */\n\n    const FOOD_DROP_COUNT = 100;\n    let mouseX = 0;\n    let mouseY = 0;\n    const smallFishes = [];\n    const foods = [];\n    let animationId;\n    const canvas = document.getElementById('landing-canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.addEventListener('mousedown', handleMouseDown, {\n      passive: true\n    });\n    canvas.addEventListener('mousemove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('mouseup', handleMouseUp, {\n      passive: true\n    });\n    canvas.addEventListener('touchstart', handleMouseDown, {\n      passive: true\n    });\n    canvas.addEventListener('touchmove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('touchend', handleMouseUp, {\n      passive: true\n    });\n    canvas.addEventListener('dblclick', handleDoubleClick, {\n      passive: true\n    });\n    const {\n      width: canvasWidth,\n      height: canvasHeight\n    } = canvas.getBoundingClientRect();\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    initializeParticles();\n    render();\n    /**\r\n     * Create the fishes with with initial positions and velocity.\r\n     */\n\n    function initializeParticles() {\n      for (let i = 0; i < SMALL_FISH.COUNT; i++) {\n        const velocity = new Vector(0, 0);\n        velocity.setAngle(Math.random() * 2 * Math.PI);\n        velocity.setLength(1);\n        const smallFish = new Particle({\n          radius: SMALL_FISH.SIZE,\n          position: new Vector(Math.random() * canvasWidth, Math.random() * canvasHeight),\n          velocity\n        });\n        smallFishes.push(smallFish);\n      }\n    }\n    /**\r\n     * Renders each frame.\r\n     */\n\n\n    function render() {\n      // Paint the canvas with transparentcy for creating the trail effect.\n      ctx.fillStyle = 'rgba(25, 30, 35, .1)';\n      ctx.fillRect(0, 0, canvasWidth, canvasHeight); // For each small fish.\n\n      for (let i = 0; i < SMALL_FISH.COUNT; i++) {\n        const smallFish = smallFishes[i];\n        let currentSmallFishAngle = smallFish.velocity.angle;\n        let attractedFood; // For each food particle.\n\n        for (let fi = 0, closestFoodDistance = 20000; fi < foods.length; fi++) {\n          const distanceToFood = foods[fi].distanceTo(smallFish); // If the food is within the food attraction raidus.\n\n          if (distanceToFood < SMALL_FISH.FOOD_ATTRACTION_RADIUS) {\n            // If the distance to the current food is less than an already known distance to food,\n            // then make it as the attracted food since it is the closest. Closest food is always\n            // consumed first.\n            if (distanceToFood < closestFoodDistance) {\n              closestFoodDistance = distanceToFood;\n              attractedFood = foods[fi];\n            } else if (distanceToFood - closestFoodDistance < 1) {\n              // This is for a case where deadlock might happen between to food particles at same distance.\n              // In that case we take the first one in the food array.\n              attractedFood = foods[fi];\n              break;\n            }\n          }\n        } // Attract to mouse pointer only if not attracted to food to avoid deadlock.\n\n\n        if (!attractedFood && mouseX && mouseY) {\n          const mousePoint = new Particle({\n            radius: 1,\n            position: new Vector(mouseX, mouseY)\n          }); // If the fish is within attraction distance to mouse point.\n\n          if (mousePoint.distanceTo(smallFish) < SMALL_FISH.MOUSE_ATTRACTION_RADIUS) {\n            // Set the fish's angle to point to the mouse point.\n            currentSmallFishAngle = smallFish.angleTo(mousePoint);\n          }\n        } // If the fish is within attraction distance to a food.\n\n\n        if (attractedFood) {\n          // Find the angle of the fish to the food.\n          currentSmallFishAngle = smallFish.angleTo(attractedFood); // If the fish has reached the food, remove the food from the food array.\n\n          if (Math.trunc(attractedFood.position.x) == Math.trunc(smallFish.position.x) && Math.trunc(attractedFood.position.y) == Math.trunc(smallFish.position.y)) {\n            const index = foods.indexOf(attractedFood);\n            foods.splice(index, 1);\n          }\n        } // Add some randomess to avoid straight line movement to the food.\n\n\n        const nextSmallFishAngle = Math.random() > 0.5 ? currentSmallFishAngle + 0.2 : currentSmallFishAngle - 0.2;\n        smallFish.velocity.setAngle(nextSmallFishAngle);\n        smallFish.updatePosition();\n        ctx.fillStyle = SMALL_FISH.COLOR;\n        smallFish.render(ctx);\n        smallFish.screenWrap(canvasWidth, canvasHeight);\n      } // Render food particles.\n\n\n      for (let i = 0; i < foods.length; i++) {\n        ctx.fillStyle = FOOD_COLOR;\n        foods[i].render(ctx);\n      }\n\n      animationId = requestAnimationFrame(render);\n    }\n    /**\r\n     * Handles mousedown and touchstart events on the canvas.\r\n     */\n\n\n    function handleMouseDown(event) {\n      if (event.touches) {\n        mouseX = event.touches[0].pageX;\n        mouseY = event.touches[0].pageY;\n      } else {\n        mouseX = event.pageX;\n        mouseY = event.pageY;\n      }\n    }\n    /**\r\n     * Handles mousemove and touchmove events on the canvas.\r\n     */\n\n\n    function handleMouseMove(event) {\n      if (mouseX && mouseY) {\n        if (event.touches) {\n          mouseX = event.touches[0].pageX;\n          mouseY = event.touches[0].pageY;\n        } else {\n          mouseX = event.pageX;\n          mouseY = event.pageY;\n        }\n      }\n    }\n    /**\r\n     * Handles mouseup and touchend events on the canvas.\r\n     */\n\n\n    function handleMouseUp() {\n      mouseX = mouseY = undefined;\n    }\n    /**\r\n     * Handles doubletap events on the canvas.\r\n     * Create a new food particle at the touch location.\r\n     */\n\n\n    function handleDoubleClick() {\n      for (let i = 0; i < FOOD_DROP_COUNT; i++) {\n        const food = new Particle({\n          radius: 1,\n          position: new Vector(Math.random() * canvasWidth, Math.random() * canvasHeight)\n        });\n        foods.push(food);\n      }\n    }\n\n    return () => {\n      canvas.addEventListener('mousedown', handleMouseDown, {\n        passive: true\n      });\n      canvas.addEventListener('mousemove', handleMouseMove, {\n        passive: true\n      });\n      canvas.addEventListener('mouseup', handleMouseUp, {\n        passive: true\n      });\n      canvas.addEventListener('touchstart', handleMouseDown, {\n        passive: true\n      });\n      canvas.addEventListener('touchmove', handleMouseMove, {\n        passive: true\n      });\n      canvas.addEventListener('touchend', handleMouseUp, {\n        passive: true\n      });\n      smallFishes.length = 0;\n      foods.length = 0;\n      cancelAnimationFrame(animationId);\n    };\n  }, []);\n}\nexport function useDrawFaceOnCanvas() {\n  /**\r\n   * The springiness of the animation.\r\n   */\n  const SPRING_COEFFICIENT = 0.09;\n  /**\r\n   * The friction of the particles.\r\n   */\n\n  const FRICTION = 0.8;\n  /**\r\n   * The stages of rendering of the face.\r\n   */\n\n  const STAGGER_SLICES = 3;\n  /**\r\n   * The time to elapse between each stage.\r\n   */\n\n  const STAGGER_INTERVAL = 3000;\n  /**\r\n   * The radius for hover affects.\r\n   */\n\n  const HOVER_CIRCLE_RADIUS = 70;\n  /**\r\n   * The radius of the particle when they are hovered.\r\n   */\n\n  const PARTICLE_HOVER_RADIUS = 3;\n  /**\r\n   * The default radius of the particle.\r\n   */\n\n  const PARTICLE_RADIUS = 1;\n  useEffect(() => {\n    let mouseX = 0;\n    let mouseY = 0;\n    const canvas = document.getElementById('about-face-canvas');\n    const ctx = canvas.getContext('2d');\n    canvas.addEventListener('mousemove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('touchstart', handleTouchStartAndEnd, {\n      passive: true\n    });\n    canvas.addEventListener('touchmove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('touchEnd', handleTouchStartAndEnd, {\n      passive: true\n    });\n    const canvasDimensions = canvas.getBoundingClientRect();\n    const {\n      left: canvasStartX,\n      top: canvasStartY\n    } = canvasDimensions;\n    let {\n      width: canvasWidth,\n      height: canvasHeight\n    } = canvas.getBoundingClientRect();\n    canvasWidth = canvas.width = roundToEven(canvasWidth);\n    canvasHeight = canvas.height = roundToEven(canvasHeight);\n    const halfCanvasWidth = canvasWidth / 2;\n    const halfCanvasHeight = canvasHeight / 2;\n    const imageSide = roundToEven(Math.min(canvasWidth, canvasHeight));\n    const imageStartX = halfCanvasWidth - imageSide / 2;\n    const imageStartY = halfCanvasHeight - imageSide / 2;\n    const img = new Image();\n    let positions = [];\n    const springPairs = [];\n    const particleColors = ['#ff2286', '#eefac9', '#363b41'];\n    let limit;\n\n    img.onload = function () {\n      positions = getImagePixelPositions();\n      initializeParticles();\n      staggerParticles();\n      render();\n    };\n\n    img.src = 'img/db_face.png';\n    /**\r\n     * Find the pixel position of all black pixels on the canvas.\r\n     */\n\n    function getImagePixelPositions() {\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      ctx.drawImage(img, imageStartX, imageStartY, imageSide, imageSide);\n      const imgData = ctx.getImageData(imageStartX, imageStartY, imageSide, imageSide);\n      const data = imgData.data;\n      const pixelPositions = []; // Iterate through each pixel data.\n\n      for (let i = 0, pixelPos = 0; i < data.length; i += 4, pixelPos += 1) {\n        const red = data[i];\n        const green = data[i + 1];\n        const blue = data[i + 2]; // Initial image is black and white. So, we find all black pixels and find their x and y positions\n        // on the canvas.\n\n        if (!(red >= 10 && green >= 10 && blue >= 10)) {\n          const x = imageStartX + Math.floor(pixelPos % imageSide);\n          const y = imageStartY + Math.floor(pixelPos / imageSide);\n          const position = new Vector(x, y);\n          pixelPositions.push(position);\n        }\n      } // We clear the canvas of the original image.\n\n\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      return pixelPositions;\n    }\n    /**\r\n     * Create the particles and spring points based on the pixel positions in the canvas.\r\n     */\n\n\n    function initializeParticles() {\n      positions.forEach((position, index) => {\n        // TODO: Remove for mobile.\n        if (index % 2) {\n          const springPoint = new Particle({\n            radius: PARTICLE_RADIUS,\n            position\n          });\n          const particle = new Particle({\n            radius: PARTICLE_RADIUS,\n            position: new Vector(Math.round(Math.random() * canvasWidth), Math.round(Math.random() * canvasHeight)),\n            friction: FRICTION\n          });\n          springPairs.push({\n            springPoint,\n            particle\n          });\n        }\n      });\n    }\n    /**\r\n     * Sets a limit on the number of particles that are rendered a time.\r\n     * Basically slices the total particles into chunks and increases limit in intervals.\r\n     */\n\n\n    function staggerParticles() {\n      limit = springPairs.length / STAGGER_SLICES;\n      const interval = setInterval(() => {\n        limit += springPairs.length / STAGGER_SLICES;\n\n        if (limit > springPairs.length) {\n          limit = springPairs.length;\n          clearInterval(interval);\n        }\n      }, STAGGER_INTERVAL);\n    }\n    /**\r\n     * Renders the particles on the screen.\r\n     */\n\n\n    function render() {\n      // Clear the canvas.\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight); // For each particle within the limit.\n\n      for (let i = 0; i < limit; i++) {\n        let {\n          springPoint\n        } = springPairs[i];\n        const {\n          particle\n        } = springPairs[i];\n\n        if (mouseX && mouseY) {\n          // The current most position if canvas is hovered.\n          const newMousePoint = new Particle({\n            radius: PARTICLE_RADIUS,\n            position: new Vector(mouseX, mouseY)\n          }); // If the distance between the current particle and mouse point is than said radius.\n\n          if (newMousePoint.distanceTo(springPoint) < HOVER_CIRCLE_RADIUS) {\n            // Find the angle to the particle's spring point from the mouse point.\n            const angleToSpringPoint = newMousePoint.angleTo(springPoint);\n            particle.radius = PARTICLE_HOVER_RADIUS; // Say if the angle between the mouse point and spring point is 30 degrees and the\n            // distance is less than HOVER_CIRCLE_RADIUS, then creaste a vector setting it in the same\n            // direction and set the distance to HOVER_CIRCLE_RADIUS.\n\n            const addition = new Vector();\n            addition.setAngle(angleToSpringPoint);\n            addition.setLength(HOVER_CIRCLE_RADIUS); // Now add the above vector to the mouse point to get a new point that is at HOVER_CIRCLE_RADIUS distance\n            // from the mouse point and in the same direction as the original spring point.\n\n            newMousePoint.position.add(addition);\n            springPoint = newMousePoint; // Since particle's udpate is set to false when springiness subsides,\n            // set it to true to animate on hover.\n\n            particle.update = true;\n          } else {\n            particle.radius = PARTICLE_RADIUS;\n          }\n        }\n\n        if (particle.update) {\n          const distance = Vector.subtract(springPoint.position, particle.position);\n          const springForce = Vector.multiply(distance, SPRING_COEFFICIENT);\n          particle.velocity.add(springForce);\n          particle.updatePosition();\n          const index = Math.floor(Math.random() * particleColors.length);\n          ctx.fillStyle = particleColors[index];\n          particle.render(ctx);\n          particle.addFriction(); // If the particle has come to stand still stop updating it.\n\n          if (distance.length < 0.0001) {\n            particle.update = false;\n          }\n        } else {\n          const index = Math.floor(Math.random() * particleColors.length);\n          ctx.fillStyle = particleColors[index];\n          particle.render(ctx);\n        }\n      }\n\n      requestAnimationFrame(render);\n    }\n\n    function handleTouchStartAndEnd() {\n      mouseX = mouseY = undefined;\n    }\n    /**\r\n     * Handles mouse movement on the canvas.\r\n     * @param param0 Ha\r\n     */\n\n\n    function handleMouseMove(event) {\n      let x, y;\n\n      if (event.touches) {\n        x = event.touches[0].pageX;\n        y = event.touches[0].pageY;\n      } else {\n        x = event.pageX;\n        y = event.pageY;\n      }\n\n      mouseX = x - canvasStartX;\n      mouseY = y - canvasStartY;\n      mouseX = mouseX < 0 ? -5000 : mouseX;\n      mouseY = mouseY < 0 ? -5000 : mouseY;\n    }\n\n    return () => {\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      positions.length = 0;\n      springPairs.length = 0;\n      limit = 0;\n    };\n  }, []);\n}\n/**\r\n * Custom hook for text effect.\r\n * @param id The id of the canvas.\r\n * @param text The text to be displayed in the canvas.\r\n */\n\nexport function useTextEffect(id, text) {\n  /**\r\n   * The default radius of the particle.\r\n   */\n  const PARTICLE_RADIUS = 1;\n  useEffect(() => {\n    setTimeout(() => {\n      const canvas = document.getElementById(id);\n      const ctx = canvas.getContext('2d');\n      const {\n        width: canvasWidth,\n        height: canvasHeight\n      } = canvas.getBoundingClientRect();\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      const halfCanvasWidth = roundToEven(canvasWidth / 2);\n      const halfCanvasHeight = roundToEven(canvasHeight / 2);\n      const particleColors = ['#ff2286', '#eefac9'];\n      let textWidth;\n      const textHeight = 200;\n      let textStartX;\n      let textStartY;\n      let data;\n      const positions = getTextPixelPositions();\n      const springPairs = [];\n      initializeParticles();\n      render();\n\n      function getTextPixelPositions() {\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = '#ffffff';\n        ctx.strokeStyle = '#ffffff';\n        ctx.font = '140px Nunito Sans';\n        textWidth = roundToEven(ctx.measureText(text).width) + 10;\n        textStartX = halfCanvasWidth - textWidth / 2 - 5;\n        textStartY = halfCanvasHeight - textHeight / 2;\n        ctx.strokeText(text, textStartX, halfCanvasHeight + 50);\n        const imgData = ctx.getImageData(textStartX, textStartY, textWidth, textHeight);\n        data = imgData.data;\n        const pixelPositions = []; // Iterate through each pixel data.\n\n        for (let i = 0, index = 0; i < data.length; i += 4, index++) {\n          const red = data[i];\n          const green = data[i + 1];\n          const blue = data[i + 2]; // Initial image is black and white. So, we find all black pixels and find their x and y positions\n          // on the canvas.\n\n          if (red >= 255 && green >= 255 && blue >= 255) {\n            const x = textStartX + index % textWidth;\n            const y = textStartY + Math.floor(index / textWidth);\n            const position = new Vector(x, y);\n            pixelPositions.push(position);\n          }\n        } // We clear the canvas of the original image.\n        // ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n\n        return pixelPositions;\n      }\n      /**\r\n       * Create the particles and spring points based on the pixel positions in the canvas.\r\n       */\n\n\n      function initializeParticles() {\n        for (let i = 0; i < positions.length; i++) {\n          const velocity = new Vector(0, 0);\n          velocity.setAngle(Math.random() * 2 * Math.PI);\n          velocity.setLength(Math.random() * 2 + 1);\n          const springPoint = new Particle({\n            radius: 1,\n            position: new Vector(positions[i].x, positions[i].y),\n            velocity\n          });\n          let position;\n          const random = Math.random();\n\n          if (random < 0.2) {\n            position = new Vector(Math.random() * canvasWidth, randomBetween(0, -300));\n          } else if (random < 0.4) {\n            position = new Vector(Math.random() * canvasWidth, randomBetween(canvasHeight, canvasHeight + 300));\n          } else if (random < 0.6) {\n            position = new Vector(randomBetween(0, -300), Math.random() * canvasHeight);\n          } else {\n            position = new Vector(randomBetween(canvasWidth, canvasWidth + 300), Math.random() * canvasHeight);\n          }\n\n          const particle = new Particle({\n            radius: PARTICLE_RADIUS,\n            position,\n            velocity,\n            friction: 0.8\n          });\n          springPairs.push({\n            particle,\n            springPoint\n          });\n        }\n      }\n      /**\r\n       * Effect to move the particles to their respective points.\r\n       */\n\n\n      function fixedBeeSwarm() {\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n        for (let i = 0; i < springPairs.length; i++) {\n          const {\n            particle,\n            springPoint\n          } = springPairs[i];\n          const angle = particle.angleTo(springPoint);\n          particle.updatePosition();\n          ctx.fillStyle = particleColors[i % 3];\n          particle.render(ctx);\n\n          if (particle.distanceTo(springPoint) < 5) {\n            particle.update = false;\n          }\n\n          particle.screenWrap(canvasWidth, canvasHeight);\n\n          if (Math.random() > 0.2) {\n            particle.velocity.setAngle(angle);\n          } else {\n            particle.velocity.setAngle(Math.random() * 2 * Math.PI);\n          }\n        }\n      }\n      /**\r\n       * Renders the particles on the screen.\r\n       */\n\n\n      function render() {\n        fixedBeeSwarm();\n        requestAnimationFrame(render);\n      }\n\n      return () => {\n        springPairs.length = 0;\n      };\n    }, 1000);\n  }, [id, text]);\n}","map":null,"metadata":{},"sourceType":"module"}