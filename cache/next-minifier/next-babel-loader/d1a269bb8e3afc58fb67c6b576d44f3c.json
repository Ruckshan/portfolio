{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Vector } from './vector';\n/**\r\n * Props for a particle.\r\n */\n\nexport class Particle {\n  constructor({\n    radius,\n    position,\n    velocity = new Vector(0, 0),\n    gravity = 0,\n    mass = 1,\n    friction = 0.99,\n    update = true\n  }) {\n    _defineProperty(this, \"radius\", void 0);\n\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"velocity\", void 0);\n\n    _defineProperty(this, \"mass\", void 0);\n\n    _defineProperty(this, \"gravity\", void 0);\n\n    _defineProperty(this, \"friction\", void 0);\n\n    _defineProperty(this, \"update\", void 0);\n\n    this.radius = radius;\n    this.position = position;\n    this.velocity = velocity;\n    this.mass = mass;\n    this.gravity = new Vector(0, gravity);\n    this.friction = friction;\n    this.update = update;\n  }\n  /**\r\n   * Add the acceleration vector to a the particles velocity.\r\n   * @param v the acceleration vector.\r\n   */\n\n\n  accelerate(v) {\n    if (this.update) {\n      this.velocity.add(v);\n    }\n  }\n  /**\r\n   * Adds friction to the particle.\r\n   */\n\n\n  addFriction() {\n    if (this.update) {\n      this.velocity.multiply(this.friction);\n    }\n  }\n  /**\r\n   * Finds the angle to a given particle from the current particle.\r\n   * @param p The particle to find the angle to.\r\n   */\n\n\n  angleTo(p) {\n    return Math.atan2(p.position.y - this.position.y, p.position.x - this.position.x);\n  }\n  /**\r\n   * Finds the distance to a given particle from the current particle.\r\n   * @param p The particle to find the distance to.\r\n   */\n\n\n  distanceTo(p) {\n    const dx = p.position.x - this.position.x;\n    const dy = p.position.y - this.position.y;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n\n  gravitateTo(p) {\n    if (this.update) {\n      const gravity = new Vector(0, 0);\n      const distance = this.distanceTo(p);\n      gravity.setLength(p.mass / (distance * distance));\n      gravity.setAngle(this.angleTo(p));\n      this.velocity.add(gravity);\n    }\n  }\n  /**\r\n   * Updates the particle's position by adding in the particle's velocity.\r\n   * Happens only if the particles update property is set to true.\r\n   */\n\n\n  updatePosition() {\n    if (this.update) {\n      this.velocity.add(this.gravity);\n      this.position.add(this.velocity);\n    }\n  }\n  /**\r\n   * Draws the particle as a circle of given radius at the current position.\r\n   * @param ctx The canvas context on which to draw to.\r\n   */\n\n\n  render(ctx) {\n    ctx.beginPath();\n    ctx.arc(this.position.x, this.position.y, this.radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n  }\n  /**\r\n   * Wraps te position to stay within the given width and height.\r\n   * @param width The width to which particle's width will be wrapped.\r\n   * @param height The height to which particle's height will be wrapped.\r\n   */\n\n\n  screenWrap(width, height) {\n    if (this.update) {\n      const {\n        x,\n        y\n      } = this.position; // Left boundary.\n\n      if (x + this.radius < 0) {\n        this.position.x = width + this.radius;\n      } // Right boundary.\n\n\n      if (x - this.radius > width) {\n        this.position.x = 0 - this.radius;\n      } // Top boundary.\n\n\n      if (y + this.radius < 0) {\n        this.position.y = height + this.radius;\n      } // Bottom boundary.\n\n\n      if (y - this.radius > height) {\n        this.position.y = 0 - this.radius;\n      }\n    }\n  }\n  /**\r\n   * This will bounce the particle of the inside the given width and heigth.\r\n   * @param width The width at which particles will be bounced off of.\r\n   * @param height The height at which particles will be bounced off of.\r\n   */\n\n\n  bounceOfEdges(width, height) {\n    if (this.update) {\n      // Left edge.\n      if (this.position.x - this.radius < 0) {\n        this.position.x = this.radius;\n        this.velocity.x *= -1;\n      } // Right edge.\n\n\n      if (this.position.x + this.radius > width) {\n        this.position.x = width - this.radius;\n        this.velocity.x *= -1;\n      } // Top edge.\n\n\n      if (this.position.y - this.radius < 0) {\n        this.position.y = this.radius;\n        this.velocity.y *= -1;\n      } // Bottom edge.\n\n\n      if (this.position.y + this.radius > height) {\n        this.position.y = height - this.radius;\n        this.velocity.y *= -1;\n      }\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}