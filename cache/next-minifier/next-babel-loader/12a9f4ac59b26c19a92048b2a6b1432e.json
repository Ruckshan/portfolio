{"ast":null,"code":"import { useEffect } from 'react';\nimport { randomBetween, roundToEven } from '.';\nimport { Particle } from './particle';\nimport { Vector } from './vector';\n/**\r\n * Custom hook used to draw the face vector on about page.\r\n */\n\nexport function useLandingPageCanvasEffect() {\n  useEffect(function () {\n    /**\r\n     * Small fish properties.\r\n     */\n    var SMALL_FISH = {\n      /**\r\n       * It's Size.\r\n       */\n      SIZE: 1,\n\n      /**\r\n       * The total number of small fish.\r\n       */\n      COUNT: 200,\n\n      /**\r\n       * The color of the small fish.\r\n       */\n      COLOR: '#eefac9',\n\n      /**\r\n       * The distance to which the small fish are attracted to food.\r\n       */\n      FOOD_ATTRACTION_RADIUS: 100,\n\n      /**\r\n       * The distance to which the small fish are attracted to mouse pointer.\r\n       */\n      MOUSE_ATTRACTION_RADIUS: 100\n    };\n    /**\r\n     * The food particle color.\r\n     */\n\n    var FOOD_COLOR = '#e6db74';\n    /**\r\n     * The number of food particles droppen when double tapped.\r\n     */\n\n    var FOOD_DROP_COUNT = 100;\n    var mouseX = 0;\n    var mouseY = 0;\n    var smallFishes = [];\n    var foods = [];\n    var animationId;\n    var canvas = document.getElementById('landing-canvas');\n    var ctx = canvas.getContext('2d');\n    canvas.addEventListener('mousedown', handleMouseDown, {\n      passive: true\n    });\n    canvas.addEventListener('mousemove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('mouseup', handleMouseUp, {\n      passive: true\n    });\n    canvas.addEventListener('touchstart', handleMouseDown, {\n      passive: true\n    });\n    canvas.addEventListener('touchmove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('touchend', handleMouseUp, {\n      passive: true\n    });\n    canvas.addEventListener('dblclick', handleDoubleClick, {\n      passive: true\n    });\n\n    var _canvas$getBoundingCl = canvas.getBoundingClientRect(),\n        canvasWidth = _canvas$getBoundingCl.width,\n        canvasHeight = _canvas$getBoundingCl.height;\n\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    initializeParticles();\n    render();\n    /**\r\n     * Create the fishes with with initial positions and velocity.\r\n     */\n\n    function initializeParticles() {\n      for (var i = 0; i < SMALL_FISH.COUNT; i++) {\n        var velocity = new Vector(0, 0);\n        velocity.setAngle(Math.random() * 2 * Math.PI);\n        velocity.setLength(1);\n        var smallFish = new Particle({\n          radius: SMALL_FISH.SIZE,\n          position: new Vector(Math.random() * canvasWidth, Math.random() * canvasHeight),\n          velocity: velocity\n        });\n        smallFishes.push(smallFish);\n      }\n    }\n    /**\r\n     * Renders each frame.\r\n     */\n\n\n    function render() {\n      // Paint the canvas with transparentcy for creating the trail effect.\n      ctx.fillStyle = 'rgba(25, 30, 35, .1)';\n      ctx.fillRect(0, 0, canvasWidth, canvasHeight); // For each small fish.\n\n      for (var i = 0; i < SMALL_FISH.COUNT; i++) {\n        var smallFish = smallFishes[i];\n        var currentSmallFishAngle = smallFish.velocity.angle;\n        var attractedFood = void 0; // For each food particle.\n\n        for (var fi = 0, closestFoodDistance = 20000; fi < foods.length; fi++) {\n          var distanceToFood = foods[fi].distanceTo(smallFish); // If the food is within the food attraction raidus.\n\n          if (distanceToFood < SMALL_FISH.FOOD_ATTRACTION_RADIUS) {\n            // If the distance to the current food is less than an already known distance to food,\n            // then make it as the attracted food since it is the closest. Closest food is always\n            // consumed first.\n            if (distanceToFood < closestFoodDistance) {\n              closestFoodDistance = distanceToFood;\n              attractedFood = foods[fi];\n            } else if (distanceToFood - closestFoodDistance < 1) {\n              // This is for a case where deadlock might happen between to food particles at same distance.\n              // In that case we take the first one in the food array.\n              attractedFood = foods[fi];\n              break;\n            }\n          }\n        } // Attract to mouse pointer only if not attracted to food to avoid deadlock.\n\n\n        if (!attractedFood && mouseX && mouseY) {\n          var mousePoint = new Particle({\n            radius: 1,\n            position: new Vector(mouseX, mouseY)\n          }); // If the fish is within attraction distance to mouse point.\n\n          if (mousePoint.distanceTo(smallFish) < SMALL_FISH.MOUSE_ATTRACTION_RADIUS) {\n            // Set the fish's angle to point to the mouse point.\n            currentSmallFishAngle = smallFish.angleTo(mousePoint);\n          }\n        } // If the fish is within attraction distance to a food.\n\n\n        if (attractedFood) {\n          // Find the angle of the fish to the food.\n          currentSmallFishAngle = smallFish.angleTo(attractedFood); // If the fish has reached the food, remove the food from the food array.\n\n          if (Math.trunc(attractedFood.position.x) == Math.trunc(smallFish.position.x) && Math.trunc(attractedFood.position.y) == Math.trunc(smallFish.position.y)) {\n            var index = foods.indexOf(attractedFood);\n            foods.splice(index, 1);\n          }\n        } // Add some randomess to avoid straight line movement to the food.\n\n\n        var nextSmallFishAngle = Math.random() > 0.5 ? currentSmallFishAngle + 0.2 : currentSmallFishAngle - 0.2;\n        smallFish.velocity.setAngle(nextSmallFishAngle);\n        smallFish.updatePosition();\n        ctx.fillStyle = SMALL_FISH.COLOR;\n        smallFish.render(ctx);\n        smallFish.screenWrap(canvasWidth, canvasHeight);\n      } // Render food particles.\n\n\n      for (var _i = 0; _i < foods.length; _i++) {\n        ctx.fillStyle = FOOD_COLOR;\n\n        foods[_i].render(ctx);\n      }\n\n      animationId = requestAnimationFrame(render);\n    }\n    /**\r\n     * Handles mousedown and touchstart events on the canvas.\r\n     */\n\n\n    function handleMouseDown(event) {\n      if (event.touches) {\n        mouseX = event.touches[0].pageX;\n        mouseY = event.touches[0].pageY;\n      } else {\n        mouseX = event.pageX;\n        mouseY = event.pageY;\n      }\n    }\n    /**\r\n     * Handles mousemove and touchmove events on the canvas.\r\n     */\n\n\n    function handleMouseMove(event) {\n      if (mouseX && mouseY) {\n        if (event.touches) {\n          mouseX = event.touches[0].pageX;\n          mouseY = event.touches[0].pageY;\n        } else {\n          mouseX = event.pageX;\n          mouseY = event.pageY;\n        }\n      }\n    }\n    /**\r\n     * Handles mouseup and touchend events on the canvas.\r\n     */\n\n\n    function handleMouseUp() {\n      mouseX = mouseY = undefined;\n    }\n    /**\r\n     * Handles doubletap events on the canvas.\r\n     * Create a new food particle at the touch location.\r\n     */\n\n\n    function handleDoubleClick() {\n      for (var i = 0; i < FOOD_DROP_COUNT; i++) {\n        var food = new Particle({\n          radius: 1,\n          position: new Vector(Math.random() * canvasWidth, Math.random() * canvasHeight)\n        });\n        foods.push(food);\n      }\n    }\n\n    return function () {\n      canvas.addEventListener('mousedown', handleMouseDown, {\n        passive: true\n      });\n      canvas.addEventListener('mousemove', handleMouseMove, {\n        passive: true\n      });\n      canvas.addEventListener('mouseup', handleMouseUp, {\n        passive: true\n      });\n      canvas.addEventListener('touchstart', handleMouseDown, {\n        passive: true\n      });\n      canvas.addEventListener('touchmove', handleMouseMove, {\n        passive: true\n      });\n      canvas.addEventListener('touchend', handleMouseUp, {\n        passive: true\n      });\n      smallFishes.length = 0;\n      foods.length = 0;\n      cancelAnimationFrame(animationId);\n    };\n  }, []);\n}\nexport function useDrawFaceOnCanvas() {\n  /**\r\n   * The springiness of the animation.\r\n   */\n  var SPRING_COEFFICIENT = 0.09;\n  /**\r\n   * The friction of the particles.\r\n   */\n\n  var FRICTION = 0.8;\n  /**\r\n   * The stages of rendering of the face.\r\n   */\n\n  var STAGGER_SLICES = 3;\n  /**\r\n   * The time to elapse between each stage.\r\n   */\n\n  var STAGGER_INTERVAL = 3000;\n  /**\r\n   * The radius for hover affects.\r\n   */\n\n  var HOVER_CIRCLE_RADIUS = 70;\n  /**\r\n   * The radius of the particle when they are hovered.\r\n   */\n\n  var PARTICLE_HOVER_RADIUS = 3;\n  /**\r\n   * The default radius of the particle.\r\n   */\n\n  var PARTICLE_RADIUS = 1;\n  useEffect(function () {\n    var mouseX = 0;\n    var mouseY = 0;\n    var canvas = document.getElementById('about-face-canvas');\n    var ctx = canvas.getContext('2d');\n    canvas.addEventListener('mousemove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('touchstart', handleTouchStartAndEnd, {\n      passive: true\n    });\n    canvas.addEventListener('touchmove', handleMouseMove, {\n      passive: true\n    });\n    canvas.addEventListener('touchEnd', handleTouchStartAndEnd, {\n      passive: true\n    });\n    var canvasDimensions = canvas.getBoundingClientRect();\n    var canvasStartX = canvasDimensions.left,\n        canvasStartY = canvasDimensions.top;\n\n    var _canvas$getBoundingCl2 = canvas.getBoundingClientRect(),\n        canvasWidth = _canvas$getBoundingCl2.width,\n        canvasHeight = _canvas$getBoundingCl2.height;\n\n    canvasWidth = canvas.width = roundToEven(canvasWidth);\n    canvasHeight = canvas.height = roundToEven(canvasHeight);\n    var halfCanvasWidth = canvasWidth / 2;\n    var halfCanvasHeight = canvasHeight / 2;\n    var imageSide = roundToEven(Math.min(canvasWidth, canvasHeight));\n    var imageStartX = halfCanvasWidth - imageSide / 2;\n    var imageStartY = halfCanvasHeight - imageSide / 2;\n    var img = new Image();\n    var positions = [];\n    var springPairs = [];\n    var particleColors = ['#ff2286', '#eefac9', '#363b41'];\n    var limit;\n\n    img.onload = function () {\n      positions = getImagePixelPositions();\n      initializeParticles();\n      staggerParticles();\n      render();\n    };\n\n    img.src = 'img/db_face.png';\n    /**\r\n     * Find the pixel position of all black pixels on the canvas.\r\n     */\n\n    function getImagePixelPositions() {\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      ctx.drawImage(img, imageStartX, imageStartY, imageSide, imageSide);\n      var imgData = ctx.getImageData(imageStartX, imageStartY, imageSide, imageSide);\n      var data = imgData.data;\n      var pixelPositions = []; // Iterate through each pixel data.\n\n      for (var i = 0, pixelPos = 0; i < data.length; i += 4, pixelPos += 1) {\n        var red = data[i];\n        var green = data[i + 1];\n        var blue = data[i + 2]; // Initial image is black and white. So, we find all black pixels and find their x and y positions\n        // on the canvas.\n\n        if (!(red >= 10 && green >= 10 && blue >= 10)) {\n          var x = imageStartX + Math.floor(pixelPos % imageSide);\n          var y = imageStartY + Math.floor(pixelPos / imageSide);\n          var position = new Vector(x, y);\n          pixelPositions.push(position);\n        }\n      } // We clear the canvas of the original image.\n\n\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n      return pixelPositions;\n    }\n    /**\r\n     * Create the particles and spring points based on the pixel positions in the canvas.\r\n     */\n\n\n    function initializeParticles() {\n      positions.forEach(function (position, index) {\n        // TODO: Remove for mobile.\n        if (index % 2) {\n          var springPoint = new Particle({\n            radius: PARTICLE_RADIUS,\n            position: position\n          });\n          var particle = new Particle({\n            radius: PARTICLE_RADIUS,\n            position: new Vector(Math.round(Math.random() * canvasWidth), Math.round(Math.random() * canvasHeight)),\n            friction: FRICTION\n          });\n          springPairs.push({\n            springPoint: springPoint,\n            particle: particle\n          });\n        }\n      });\n    }\n    /**\r\n     * Sets a limit on the number of particles that are rendered a time.\r\n     * Basically slices the total particles into chunks and increases limit in intervals.\r\n     */\n\n\n    function staggerParticles() {\n      limit = springPairs.length / STAGGER_SLICES;\n      var interval = setInterval(function () {\n        limit += springPairs.length / STAGGER_SLICES;\n\n        if (limit > springPairs.length) {\n          limit = springPairs.length;\n          clearInterval(interval);\n        }\n      }, STAGGER_INTERVAL);\n    }\n    /**\r\n     * Renders the particles on the screen.\r\n     */\n\n\n    function render() {\n      // Clear the canvas.\n      ctx.clearRect(0, 0, canvasWidth, canvasHeight); // For each particle within the limit.\n\n      for (var i = 0; i < limit; i++) {\n        var springPoint = springPairs[i].springPoint;\n        var particle = springPairs[i].particle;\n\n        if (mouseX && mouseY) {\n          // The current most position if canvas is hovered.\n          var newMousePoint = new Particle({\n            radius: PARTICLE_RADIUS,\n            position: new Vector(mouseX, mouseY)\n          }); // If the distance between the current particle and mouse point is than said radius.\n\n          if (newMousePoint.distanceTo(springPoint) < HOVER_CIRCLE_RADIUS) {\n            // Find the angle to the particle's spring point from the mouse point.\n            var angleToSpringPoint = newMousePoint.angleTo(springPoint);\n            particle.radius = PARTICLE_HOVER_RADIUS; // Say if the angle between the mouse point and spring point is 30 degrees and the\n            // distance is less than HOVER_CIRCLE_RADIUS, then creaste a vector setting it in the same\n            // direction and set the distance to HOVER_CIRCLE_RADIUS.\n\n            var addition = new Vector();\n            addition.setAngle(angleToSpringPoint);\n            addition.setLength(HOVER_CIRCLE_RADIUS); // Now add the above vector to the mouse point to get a new point that is at HOVER_CIRCLE_RADIUS distance\n            // from the mouse point and in the same direction as the original spring point.\n\n            newMousePoint.position.add(addition);\n            springPoint = newMousePoint; // Since particle's udpate is set to false when springiness subsides,\n            // set it to true to animate on hover.\n\n            particle.update = true;\n          } else {\n            particle.radius = PARTICLE_RADIUS;\n          }\n        }\n\n        if (particle.update) {\n          var distance = Vector.subtract(springPoint.position, particle.position);\n          var springForce = Vector.multiply(distance, SPRING_COEFFICIENT);\n          particle.velocity.add(springForce);\n          particle.updatePosition();\n          var index = Math.floor(Math.random() * particleColors.length);\n          ctx.fillStyle = particleColors[index];\n          particle.render(ctx);\n          particle.addFriction(); // If the particle has come to stand still stop updating it.\n\n          if (distance.length < 0.0001) {\n            particle.update = false;\n          }\n        } else {\n          var _index = Math.floor(Math.random() * particleColors.length);\n\n          ctx.fillStyle = particleColors[_index];\n          particle.render(ctx);\n        }\n      }\n\n      requestAnimationFrame(render);\n    }\n\n    function handleTouchStartAndEnd() {\n      mouseX = mouseY = undefined;\n    }\n    /**\r\n     * Handles mouse movement on the canvas.\r\n     * @param param0 Ha\r\n     */\n\n\n    function handleMouseMove(event) {\n      var x, y;\n\n      if (event.touches) {\n        x = event.touches[0].pageX;\n        y = event.touches[0].pageY;\n      } else {\n        x = event.pageX;\n        y = event.pageY;\n      }\n\n      mouseX = x - canvasStartX;\n      mouseY = y - canvasStartY;\n      mouseX = mouseX < 0 ? -5000 : mouseX;\n      mouseY = mouseY < 0 ? -5000 : mouseY;\n    }\n\n    return function () {\n      canvas.removeEventListener('mousemove', handleMouseMove);\n      positions.length = 0;\n      springPairs.length = 0;\n      limit = 0;\n    };\n  }, []);\n}\n/**\r\n * Custom hook for text effect.\r\n * @param id The id of the canvas.\r\n * @param text The text to be displayed in the canvas.\r\n */\n\nexport function useTextEffect(id, text) {\n  /**\r\n   * The default radius of the particle.\r\n   */\n  var PARTICLE_RADIUS = 1;\n  useEffect(function () {\n    setTimeout(function () {\n      var canvas = document.getElementById(id);\n      var ctx = canvas.getContext('2d');\n\n      var _canvas$getBoundingCl3 = canvas.getBoundingClientRect(),\n          canvasWidth = _canvas$getBoundingCl3.width,\n          canvasHeight = _canvas$getBoundingCl3.height;\n\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      var halfCanvasWidth = roundToEven(canvasWidth / 2);\n      var halfCanvasHeight = roundToEven(canvasHeight / 2);\n      var particleColors = ['#ff2286', '#eefac9'];\n      var textWidth;\n      var textHeight = 200;\n      var textStartX;\n      var textStartY;\n      var data;\n      var positions = getTextPixelPositions();\n      var springPairs = [];\n      initializeParticles();\n      render();\n\n      function getTextPixelPositions() {\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n        ctx.fillStyle = '#ffffff';\n        ctx.strokeStyle = '#ffffff';\n        ctx.font = '140px Nunito Sans';\n        textWidth = roundToEven(ctx.measureText(text).width) + 10;\n        textStartX = halfCanvasWidth - textWidth / 2 - 5;\n        textStartY = halfCanvasHeight - textHeight / 2;\n        ctx.strokeText(text, textStartX, halfCanvasHeight + 50);\n        var imgData = ctx.getImageData(textStartX, textStartY, textWidth, textHeight);\n        data = imgData.data;\n        var pixelPositions = []; // Iterate through each pixel data.\n\n        for (var i = 0, index = 0; i < data.length; i += 4, index++) {\n          var red = data[i];\n          var green = data[i + 1];\n          var blue = data[i + 2]; // Initial image is black and white. So, we find all black pixels and find their x and y positions\n          // on the canvas.\n\n          if (red >= 255 && green >= 255 && blue >= 255) {\n            var x = textStartX + index % textWidth;\n            var y = textStartY + Math.floor(index / textWidth);\n            var position = new Vector(x, y);\n            pixelPositions.push(position);\n          }\n        } // We clear the canvas of the original image.\n        // ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n\n        return pixelPositions;\n      }\n      /**\r\n       * Create the particles and spring points based on the pixel positions in the canvas.\r\n       */\n\n\n      function initializeParticles() {\n        for (var i = 0; i < positions.length; i++) {\n          var velocity = new Vector(0, 0);\n          velocity.setAngle(Math.random() * 2 * Math.PI);\n          velocity.setLength(Math.random() * 2 + 1);\n          var springPoint = new Particle({\n            radius: 1,\n            position: new Vector(positions[i].x, positions[i].y),\n            velocity: velocity\n          });\n          var position = void 0;\n          var random = Math.random();\n\n          if (random < 0.2) {\n            position = new Vector(Math.random() * canvasWidth, randomBetween(0, -300));\n          } else if (random < 0.4) {\n            position = new Vector(Math.random() * canvasWidth, randomBetween(canvasHeight, canvasHeight + 300));\n          } else if (random < 0.6) {\n            position = new Vector(randomBetween(0, -300), Math.random() * canvasHeight);\n          } else {\n            position = new Vector(randomBetween(canvasWidth, canvasWidth + 300), Math.random() * canvasHeight);\n          }\n\n          var particle = new Particle({\n            radius: PARTICLE_RADIUS,\n            position: position,\n            velocity: velocity,\n            friction: 0.8\n          });\n          springPairs.push({\n            particle: particle,\n            springPoint: springPoint\n          });\n        }\n      }\n      /**\r\n       * Effect to move the particles to their respective points.\r\n       */\n\n\n      function fixedBeeSwarm() {\n        ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n\n        for (var i = 0; i < springPairs.length; i++) {\n          var _springPairs$i = springPairs[i],\n              particle = _springPairs$i.particle,\n              springPoint = _springPairs$i.springPoint;\n          var angle = particle.angleTo(springPoint);\n          particle.updatePosition();\n          ctx.fillStyle = particleColors[i % 3];\n          particle.render(ctx);\n\n          if (particle.distanceTo(springPoint) < 5) {\n            particle.update = false;\n          }\n\n          particle.screenWrap(canvasWidth, canvasHeight);\n\n          if (Math.random() > 0.2) {\n            particle.velocity.setAngle(angle);\n          } else {\n            particle.velocity.setAngle(Math.random() * 2 * Math.PI);\n          }\n        }\n      }\n      /**\r\n       * Renders the particles on the screen.\r\n       */\n\n\n      function render() {\n        fixedBeeSwarm();\n        requestAnimationFrame(render);\n      }\n\n      return function () {\n        springPairs.length = 0;\n      };\n    }, 1000);\n  }, [id, text]);\n}","map":null,"metadata":{},"sourceType":"module"}